<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS,Protocol,面向协议,">










<meta name="description" content="Protocol 的初探学习 POP面向协议编程, POP(Protocol Orientation programing).旨在提供一种 code 的架构方案, 其中解决的一个问题是在不同的类型之间共享代码.避免为了共享代码而不断的抽取父类, 最终形成一个很大的父类…. 比如 JSONAble 的类型, 使用协议的话能解决之前我的一个问题:返回的数据是一个 annotation 类型的, 可以通">
<meta name="keywords" content="iOS,Protocol,面向协议">
<meta property="og:type" content="article">
<meta property="og:title" content="Protocol 的初探学习">
<meta property="og:url" content="http://yoursite.com/2019/02/18/Protocol-de-chu-tan-xue-xi/index.html">
<meta property="og:site_name" content="一团线">
<meta property="og:description" content="Protocol 的初探学习 POP面向协议编程, POP(Protocol Orientation programing).旨在提供一种 code 的架构方案, 其中解决的一个问题是在不同的类型之间共享代码.避免为了共享代码而不断的抽取父类, 最终形成一个很大的父类…. 比如 JSONAble 的类型, 使用协议的话能解决之前我的一个问题:返回的数据是一个 annotation 类型的, 可以通">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-02-19T17:54:41.732Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Protocol 的初探学习">
<meta name="twitter:description" content="Protocol 的初探学习 POP面向协议编程, POP(Protocol Orientation programing).旨在提供一种 code 的架构方案, 其中解决的一个问题是在不同的类型之间共享代码.避免为了共享代码而不断的抽取父类, 最终形成一个很大的父类…. 比如 JSONAble 的类型, 使用协议的话能解决之前我的一个问题:返回的数据是一个 annotation 类型的, 可以通">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/18/Protocol-de-chu-tan-xue-xi/">





  <title>Protocol 的初探学习 | 一团线</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一团线</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">my someeeeeee blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/18/Protocol-de-chu-tan-xue-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="takeTrace">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一团线">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Protocol 的初探学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T12:33:27+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index">
                    <span itemprop="name">Tech</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/18/Protocol-de-chu-tan-xue-xi/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/18/Protocol-de-chu-tan-xue-xi/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Protocol 的初探学习</p>
<h1 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h1><p>面向协议编程, POP(Protocol Orientation programing).<br>旨在提供一种 code 的架构方案, 其中解决的一个问题是在不同的类型之间共享代码.避免为了共享代码而不断的抽取父类, 最终形成一个很大的父类….</p>
<p>比如 JSONAble 的类型, 使用协议的话能解决之前我的一个问题:<br>返回的数据是一个 annotation 类型的, 可以通过 JSONAbleType 转换json, 但是这个 Annotation 类型又必须是BMAnnotation 类型, 这样才能将 [annotation] 传递给 Map 显示出来,<br>而 JSONAble 又是一个想保证其子类都有一个转换 json 的方法, 这种情况下使用协议我觉得就很好. 声明骨架, 传递这个类中该有的最基本的信息(类似就是 OC 中的了).<br>而且 Protocol 可以声明一个 init 构造方法, 这样不管哪个类遵守, 都需要有这个 init, Protocol 声明这个 init, 就不需要指定类型来创建一个类了.<br>起码在这个层面上来说, 挺方便, 即不用在遵守的类写上 final(这样就没有子类了, 不是个很道德的方法….), 遵守的类依然可以通过继承让其子类共用自己的方法.</p>
<p>通过 Protocol 声明的.init 方法在实现时需要 require 关键字(对于 struct 不需要 require 关键字)</p>
<h2 id="在不同类之间共享代码"><a href="#在不同类之间共享代码" class="headerlink" title="在不同类之间共享代码"></a>在不同类之间共享代码</h2><p>其实这也是一种解决多继承的方法, 在 Java8中好像也有类似的东西, 都是 interface + implement<br>像一些操作类型的, 工具类型的代码, 或者一些不同类之间的共性, 可以抽成协议类型. 举个栗子, 对地图的操作, 不一定是 MapViewController 需要, 虽然可以继承来实现共用代码, 但是一些不应该是 mapView 的类, 也需要能有操作地图的基本方法时, 就发生了该继承谁的冲突, 用继承的方法的话旧会有为了使用地图的方法就生成了一个不伦不类的class 出来, 逻辑上会很奇怪.<br>抽象点说比如飞行这个技能的基本属性和方式, 不一定是生物才有, 飞机也有. 有时候是同一个父类的东西, 不一定都会需要有同一个方法, 例如鸡也算是鸟类, 但不会飞. 这时将”飞”这个技能定义成一个协议的话, 就能灵活的确定那个 class 拥有飞行的方法, 这样旧能在不同的类中使用相同的方法或者有同一个声明, 在传递参数类型时可以使用这些方法, 也避免了因为继承而去拥有不该有的方法.</p>
<p>这里有一个情况: 一个类遵守了两个 Protocol, 其中都对一个属性进行了默认实现, 这时这个类就不能使用默认的 extension 中的实现了, 需要自己实现这个属性或者方法</p>
<h2 id="在-Protocol’s-extension-中使用-self"><a href="#在-Protocol’s-extension-中使用-self" class="headerlink" title="在 Protocol’s extension 中使用 self"></a>在 Protocol’s extension 中使用 self</h2><p>因为不知道谁遵守的 Protocol, 里面有什么, 所以字啊 extension 中使用 self 就会产生一些不明确, 要想使用的话, 需要加一些限制条件, 或者就取值操作而言, 可以直接使用 self</p>
<h2 id="限制-Protocol-只能被-class-遵守"><a href="#限制-Protocol-只能被-class-遵守" class="headerlink" title="限制 Protocol 只能被 class 遵守"></a>限制 Protocol 只能被 class 遵守</h2><p>protocol name: class {<br>}<br>声明这个 class 的 Protocol, 使用这个协议的才可以声明为 weak 类型</p>
<h2 id="限制只能被某个-class-遵守"><a href="#限制只能被某个-class-遵守" class="headerlink" title="限制只能被某个 class 遵守"></a>限制只能被某个 class 遵守</h2><p>protocol name where Self: UIViewController {<br>}</p>
<h1 id="其并不是一个银弹-“银弹”是指一项可使软件工程的生产力在十年内提高十倍的技术或方法-即不是在各方面各场合都是最合适的"><a href="#其并不是一个银弹-“银弹”是指一项可使软件工程的生产力在十年内提高十倍的技术或方法-即不是在各方面各场合都是最合适的" class="headerlink" title="其并不是一个银弹(“银弹”是指一项可使软件工程的生产力在十年内提高十倍的技术或方法), 即不是在各方面各场合都是最合适的"></a>其并不是一个银弹(“银弹”是指一项可使软件工程的生产力在十年内提高十倍的技术或方法), 即不是在各方面各场合都是最合适的</h1><p><a href="http://www.infoq.com/cn/articles/protocol-oriented-programming-is-not-a-silver-bullet" target="_blank" rel="noopener">参考</a><br>这篇文介绍了Swift 中 Protocol 滥用的情况, 认为很多时候有更简单的方法, 没必要一定使用 Protocol<br>在 Swift 的 Protocol 出现 extension 的使用之后, 很多人都会选择首先考虑通过能不能通过 Protocol 的方式完成任务, 我一开始使用的时候也是这样, 而且也碰到了不少坑…</p>
<p>“在Swift语言中，面向协议编程很流行。在“面向协议”那儿有很多Swift代码，一些开源库甚至将其声明为功能。我觉得协议在Swift中被过度滥用了，其实问题常常可以用更简单的方式来解决。简而言之，就是不要生搬硬套协议的条条框框，而不知变通。”</p>
<p>我觉得这句说的不错, 适用是分场景的, 合适的场景用合适的方案, 效率才会高点</p>
<p>但是在适合使用 Protocol 的情况下使用, 确实是一种比使用类更好的方式</p>
<p>有时候类的解决的好的, 协议不一定适用, 比如协议的 extension 中写了默认的最基本的实现, 但是类中要有特定的实现(其中包括基本实现)时, 不能对 Protocol 的 extension 进行 override, 这样那部分基础的function 就没有了复用的功能.</p>
<p>最后, 起码在传递类型时, Protocol 是好用的, 这和 OC 的 Protocol 作用又是一样的了.<br>所以, Swift 中 Protocol 的适用范围也是有限的, 在合适的条件下使用才能发挥他的便利性, 不然也只是瞎忙而已…<br>我觉得目前 Protocol 适用的地方有几个,</p>
<ol>
<li>像OC 一样作为类的协议进行弱引用</li>
<li>构建一个框架进行传递(好像就是1.所做的)</li>
<li>共用相同的代码(而这个和全局函数作用又一样)</li>
<li>需要共用代码, 又需要传递这个类拥有这个代码的信息</li>
<li>定义相同行为的时候而这些行为又是完全相同的(即相对于1是有个 extension 的默认实现)</li>
<li>好像现在对于 Protocol 的观点也是和我一样, 一片混乱…有人说这么做很好…有人说这么做挺不好…两种文章读下去, 感觉他们说的都挺有道理, 然后我也陷入的混乱.</li>
<li>最后的总结就是…当类继承会不满足需求时, 考虑使用协议来声明方法甚至默认实现来在调用函数时传递这么个类型来调用某个方法.<br>code</li>
</ol>
<p>我遇到的一些问题和注意事项:<br>不要字啊 extension 中 override 方法, 需要 override 的方法也不要写在 extension 中….这样…可以避免很多莫名其妙的问题…<br>这个在 Protocol 中也奏效. 当Protocol 中只在 extension 中写了 function 的话, 遵守的类 override 后, 调用这些 func 时会直接调用到 Protocol extension 中的实现</p>
<p>顺便说下, 结构体的值传递方式在对 cell bean 的传递方式感觉不是很友好, 或者是我没有掌握号结构体的使用方式, 毕竟现在还是用的挺少的</p>
<p><a href="https://www.cnswift.org/protocols#spl-4" target="_blank" rel="noopener">参考帖子</a></p>
<ul>
<li>类遵守多个Protocol: 用逗号分割</li>
<li>属性遵守多个Protocol: 用 &amp; 连接</li>
</ul>
<p>对于协议中的可选方法, 在调用的时候未必会有实现, 在OC中可以用 [delegate responseto:(方法)]来判断是否有实现, Swift中是用?来使用可选链. :<br>delegate?.function?(实参)</p>
<h1 id="对于仅限于类遵守的协议"><a href="#对于仅限于类遵守的协议" class="headerlink" title="对于仅限于类遵守的协议"></a>对于仅限于类遵守的协议</h1><p>有时候定义某个Protocol时, 设计上只要class来遵守, 其他的不予遵守, 这时候可以在声明Protocol的时候, 加上”class”的限定关键字, 且需要在最前端:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol fly: class &#123;</span><br><span class="line">	var name: String &#123;get&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h1><p>一个类遵守多个协议时, 用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123;</span><br><span class="line">    print(&quot;Happy birthday, \(celebrator.name), you&apos;re \(celebrator.age)!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="要求某个传入的参数遵守多个协议"><a href="#要求某个传入的参数遵守多个协议" class="headerlink" title="要求某个传入的参数遵守多个协议"></a>要求某个传入的参数遵守多个协议</h3><p>只需要将要求遵守的协议用”&amp;”连接起来即可</p>
<h3 id="可选协议的声明"><a href="#可选协议的声明" class="headerlink" title="可选协议的声明"></a>可选协议的声明</h3><p>你可以给协议定义可选要求，这些要求不需要强制遵循协议的类型实现。可选要求使用 optional 修饰符作为前缀放在协议的定义中。可选要求允许你的代码与 Objective-C 操作。协议和可选要求必须使用 @objc 标志标记。注意 @objc 协议只能被继承自 Objective-C 类或其他 @objc 类采纳。它们不能被结构体或者枚举采纳。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol CounterDataSource &#123;</span><br><span class="line">    @objc optional func increment(forCount count: Int) -&gt; Int</span><br><span class="line">    @objc optional var fixedIncrement: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>看到<a href="https://academy.realm.io/cn/posts/appbuilders-natasha-muraschev-practical-protocol-oriented-programming/" target="_blank" rel="noopener">这篇文章</a>, 可以说是对协议的具体使用的很好的范例有了一个认识, 里面介绍了在我们开发中常见的场景中使用 <code>POP</code> 来提高代码的效率和可读性.</p>
<p>(以下记录仅仅是简单的概括这片文章, 达到自己能看到这些, 就能对应的想到原文描述的东西, 记关键节点,不记叶子)</p>
<hr>
<h3 id="实践-POP"><a href="#实践-POP" class="headerlink" title="实践 POP"></a>实践 POP</h3><h4 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h4><p>总有一些需求, 在 A View 需要一些功能啦, 过一段时间, B View 也需要这个功能了, 肿么办… 复制粘贴?  (拿到砍啊! 放个二维码, 打款来再说…)</p>
<p>好吧, 当你意识到不会就这么2个东西需要这样的时候, 就应该想着抽象出来了. 那么, 这个功能放在哪里就需要想想了~ 不能如果对这个功能有修改, 就要修改几个地方?</p>
<p>放在 <code>super view</code> 的分类或者扩展中? 嗯, 不错~  一直以来都是这么干的, 但是这样会有个结构上的问题. 这个 <code>super view</code> 会越来越臃肿… 而且其他继承自这个 <code>super view</code> 也会有这些功能了, 不管是不是逻辑上会需要…</p>
<p><strong>协议的出现</strong></p>
<p>protocol 么在<code>OC</code>就有了啊, 但是为什么现在才能更好的解决这个问题咧?</p>
<p>在 Swift 的协议刚出来的时候, 他的扩展也很弱, 没什么卵用. 后来, 大招就来了, 可以在协议扩展里添加一个默认实现的方法, 遵守协议的如果没有自己实现, 会使用声明这个扩展时做的默认实现~</p>
<p>这样我们就可以从父类中逃脱, 不用老是什么都加到父类去了~</p>
<p>例子: (采用原文)</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Shakeable.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Shakeable</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Shakeable</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">shake</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// implementation code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在协议扩展的帮组下, 你可以限制再一个特定的类里, 这样, 又做了一层控制, 并不是每个遵守这个协议的都有这个方法, 遵守协议的特定的类才有, 如例子中的: <code>extension Shakeable where Self: UIView</code>, 这个只有是<code>UIView</code>的才可以有这个默认实现.</p>
<p>在需要这个功能的<code>View</code>中, 我们只需要:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodImageView</span>: <span class="title">UIImageView</span>, <span class="title">Shakeable</span>, <span class="title">Dimmable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你不需要这个<code>View</code> 有某个功能时, 仅仅做的是不去遵守对应的协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodImageView</span>: <span class="title">UIImageView</span>, <span class="title">Dimmable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过协议, 我们可以很容易的获得乐高似的结构, 如果想学习使用协议更强大的使用方式的话, 可以看看<a href="http://archive.is/h2ZTz" target="_blank" rel="noopener">这篇文章</a>, 试试创建一个有过度效果的可调暗视图.</p>
<h4 id="UITable-ViewController"><a href="#UITable-ViewController" class="headerlink" title="(UITable)ViewController"></a>(UITable)ViewController</h4><p><code>TableView/CollectionView</code> Controller  算是在 iOS 中接触的最频繁的两个类了, 看看这里是怎么在使用这些的时候通过协议来提高效率的, <strong>这里提到的方法很斯巴拉西! 其中还涉及到了泛型的使用, 从 <code>OC</code> 转来的, 想必这些例子是十分有用了, 我是这么想的 :)</strong></p>
<p>使用一个<code>tableview</code> 去展示一些事物, 这是我们经常做的事情, 在之前, 在 controller 配置通用的做法是(): <code>用不同的 Nib/类名 &amp; ReuseIdentifier 注册一个 Cell 的类</code> -&gt; 在代理中根据<code>ReuseIdentifier</code>获取这个类, 然后使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FoodLaLaViewController</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> foodCellNib = <span class="type">UINib</span>(<span class="type">NibName</span>: <span class="string">"FoodTableViewCell"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    tableView.registerNib(foodCellNib,</span><br><span class="line">                          forCellReuseIdentifier: <span class="string">"FoodTableViewCell"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or doing like this</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableViewsDelegateMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//  这里可以直接用 String(ClassName) 来获得某个类的字符串化</span></span><br><span class="line">    <span class="keyword">let</span> foodCellNib = <span class="type">UINib</span>(<span class="type">NibName</span>: <span class="type">String</span>(<span class="type">FoodTableViewCell</span>), bundle: <span class="literal">nil</span>)</span><br><span class="line">    tableView.registerNib(foodCellNib,</span><br><span class="line">                      forCellReuseIdentifier: <span class="type">String</span>(<span class="type">FoodTableViewCell</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>so, 用 String() 对于直接使用”字符串”已经很好了, 但是, 在<code>Protocol</code> 面前, 这样就够了吗? Hell No!</p>
<p>我们需要更懒的方法!</p>
<p>so, here is the code</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先来个协议, 表示这个类是一个 可重用的东西</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ReusableView</span>: <span class="title">class</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//  在扩展这个嘞, 提供一个 static 的计算属性, 返回这个 identifier</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ReusableView</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> reuseIdentifier: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  你想那个 View 有这个 reuseIdentifier?</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableViewCell</span>: <span class="title">ReusableView</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//   然后就可以这么用</span></span><br><span class="line"><span class="type">FoodTableViewCell</span>.reuseIdentifier  <span class="comment">// 斯巴拉西!</span></span><br></pre></td></tr></table></figure>
<p>还有 Nid 加载的, 也可以用 protocol 来做</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NibLoadableView</span>: <span class="title">class</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NibLoadableView</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">NibName</span>: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FoodTableViewCell</span>: <span class="title">NibLoadableView</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">FoodTableViewCell</span>.<span class="type">NibName</span></span><br></pre></td></tr></table></figure>
<p>最后, 我们用起来会是像这样,</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> foodCellNib = <span class="type">UINib</span>(<span class="type">NibName</span>: <span class="type">FoodTableViewCell</span>.<span class="type">NibName</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">tableView.registerNib(foodCellNib,</span><br><span class="line">                      forCellReuseIdentifier: <span class="type">FoodTableViewCell</span>.reuseIdentifier)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 cell 是这样了, 我们还需要更懒一点, 就想给注册这个 cell 而已, 还要拿 nib, 还要拿 reuseIdentifier 也太麻烦了把, 这样~</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableView</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  这里使用泛型, 我们说这里接收一个类型它遵守两种协议</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">register</span>&lt;T: UITableViewCell where T: ReusableView, T: NibLoadableView&gt;<span class="params">(<span class="number">_</span>: T.<span class="keyword">Type</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//  因为泛型的限制, 我们可以拿到 NibName, 拿到 ReuseIdentifier</span></span><br><span class="line">        <span class="keyword">let</span> <span class="type">Nib</span> = <span class="type">UINib</span>(<span class="type">NibName</span>: <span class="type">T</span>.<span class="type">NibName</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">        registerNib(<span class="type">Nib</span>, forCellReuseIdentifier: <span class="type">T</span>.reuseIdentifier)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们给 UITableView 也搞一个扩展(这里不用协议哦, 因为就 UITableView 这个类扩展了这个方法, 毕竟只有这个类是这么用的)</p>
<p>然后我们给<code>tableView</code> 注册一个 Cell, 只需要这样就好了 只需要一行代码, 就完成了注册一个 cell, 不需要任何字符串<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableView.register(<span class="type">FoodTableViewCell</span>)</span><br></pre></td></tr></table></figure></p>
<p>另外, 在使用的时候, 我们也需要<code>dequeue</code>某个 cell 来使用, 能不能也简单点咧? 而且具有通用性? of course!</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableView</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩展一个 dequeue 的函数, 接手 IndexPath, 设置一个泛型作为˙返回值, 这个类型是一个遵守`ReusableView` 的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableCell</span>&lt;T: UITableViewCell where T: ReusableView&gt;<span class="params">(forIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="comment">//  根据 reuseIdentifier 拿到这个 cell, 返回</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cell = dequeueReusableCellWithIdentifier(<span class="type">T</span>.reuseIdentifier, forIndexPath: indexPath) <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  拿不到就抛出异常</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Could not dequeue cell with identifier: \(T.reuseIdentifier)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样, 就可以从之前的代码形式:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(“<span class="type">FoodTableViewCell</span><span class="string">", forIndexPath: indexPath)</span></span><br><span class="line"><span class="string">    as? FoodTableViewCell</span></span><br><span class="line"><span class="string">    else &#123;</span></span><br><span class="line"><span class="string">      fatalError("</span><span class="type">Could</span> not dequeue cell with identifier: <span class="type">FoodTableViewCell</span><span class="string">")</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>换成现在这样的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cell = tableView.dequeueReusableCell(forIndexPath: indexPath) <span class="keyword">as</span> <span class="type">FoodTableViewCell</span></span><br></pre></td></tr></table></figure>
<p>甚至不同类的 cell</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> indexPath.row == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tableView.dequeueReusableCell(forIndexPath: indexPath) <span class="keyword">as</span> <span class="type">DesertTableViewCell</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tableView.dequeueReusableCell(forIndexPath: indexPath) <span class="keyword">as</span> <span class="type">FoodTableViewCell</span></span><br></pre></td></tr></table></figure>
<p><strong>iOS Cell 注册 &amp; 用 Swift 协议扩展和泛型来实现复用</strong></p>
<blockquote>
<p>这部分源自 <a href="https://medium.com/@gonzalezreal/ios-cell-registration-reusing-with-swift-protocol-extensions-and-generics-c5ac4fb5b75e#.q2cztagj8" target="_blank" rel="noopener">Guille Gonzalez</a>，他把这个原则���用到 collection view 上，你也可以把这个方法运用到其他你有问题的 UIKit 的组件上，例如 <a href="https://www.natashatherobot.com/protocol-oriented-segue-identifiers-swift/" target="_blank" rel="noopener">Swift 中面向协议的 Segue 标识符</a>。你可以在每天的编程中都像那样使用协议，这样也会安全些。它也是源自 Apple 去年 WWDC 上的例子。面向协议编程真的很棒。</p>
</blockquote>
<p>更新2018-09-22 14:06:35: 看到一个库, <a href="https://swift.gg/2016/01/27/generic-tableviewcells/" target="_blank" rel="noopener">有博客, 还有 SwiftGG 的翻译: </a></p>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>我们要怎么使用协议来优化我们在网络调用时候的写法?</p>
<p>比如我们说, 我们有一个 Service, 里面有<code>get</code>函数来发起请求</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FoodService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(completionHandler: Result&lt;[Food]&gt; -&gt; Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">// make asynchronous API call</span></span><br><span class="line">        <span class="comment">// and return appropriate result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  我将使用结果枚举，这是在Swift里面源自 Haskel 的常见模式。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 结果枚举很简单。当服务器返回结果的时候，我们能把它解析为成功然后返回一个这个泛型确定的东西。如果失败了，我们能返回一个错误码，然后完成句柄中的 view controller 会知道如何处理这些情况。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(<span class="type">ErrorType</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们再<code>VeiwController</code> 中处理这个行为</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FoodLaLaViewController</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dataSource = [<span class="type">Food</span>]() &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        tableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    getFood()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">getFood</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">FoodService</span>().getFood() &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> result &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> food):</span><br><span class="line">            <span class="keyword">self</span>?.dataSource = food</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">self</span>?.showError(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是一个典型的调用 API 的模式。但是整个 view controller 依赖上食物数组的加载了：如果没有数据或者数据错误，它会失败。确认 view controller 是按预期正确处理了数据的最好方式是……测试。</p>
</blockquote>
<p>测试么…在这里测试是很痛苦的, 有了各种东西, 我们都部署很可控, 所以, 需要改变一些结构和方法, 让我们的测试能顺利点进行.</p>
<p>首先是, 这个<code>Service</code> 为什么是自爱 <code>getFood</code> 方法里创建的, 外部对这个<code>Service</code> 不具有可控性, 不好测试, 我们需要对这个<code>FoodService</code> 又更多的控制, 需要把<code>getFood</code>  改成这样, 才能在测试时注入我们能控制的东西</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FoodLaLaViewController</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFood</span><span class="params">(fromService service: FoodService)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    service.getFood() &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// handle result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//`测试方法`</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// FoodLaLaViewControllerTests</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFetchFood</span><span class="params">()</span></span> &#123;</span><br><span class="line">    viewController.getFood(fromService: <span class="type">FoodService</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now what?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们怎么提供一个测试的<code>Service</code>?</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FoodService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(completionHandler: Result&lt;[Food]&gt; -&gt; Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">// make asynchronous API call</span></span><br><span class="line">        <span class="comment">// and return appropriate result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个值类型, 也就是你不能创建他的子类, 反而, 你应该使用协议, 你可以想像, 每个<code>Service</code> 都会有 <code>get</code>, 都有类似这种网络的请求方法, 我们需要一个协议把它抽象出来</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Gettable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(completionHandler: Result&lt;T&gt; -&gt; Void)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用协议和泛型, 来降调用的类, 返回的数据进行通用化, 我们说每一个遵循 Gettable 协议的地方都有 get 函数，而且它接收一个完成句柄和这个类型的结果。在我们的例子中，这会是 food (但是在 dessert 服务中，它会是 dessert；这是能互相交换的)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FoodService</span>: <span class="title">Gettable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  这里通过实现方法, 指定了 `T` 为`[Food]`</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(completionHandler: Result&lt;[Food]&gt; -&gt; Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">// make asynchronous API call</span></span><br><span class="line">        <span class="comment">// and return appropriate result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 food 服务，唯一的改变就是它需要遵循 Gettable 协议。 get 函数已经实现了。它只需要接收一个 completionHandler，这个句柄接收结果的条目……因为相关类型的协议是智能的 (结果是 food 数组，相关类型就是 food 数组)。你不需要描述它。</p>
<p>回到 view controller，这基本上就是一样的了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FoodLaLaViewController</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">唯一的区别就是你需要的相关类型只能是 food 数组 (你可不希望我们的 food view controller 调用 dessert 服务)。你想限制它，然后说明这个 getFood() 函数只能获得 food 条目的结果。否则，它就是其他遵循 <span class="type">Gettable</span> 协议的东西。这使得我们能对传入的，诸如 <span class="type">FoodService</span> 的参数有更强的控制 – 因为它不需要一定是 <span class="type">FoodService</span>，我们能注入其他的东西。</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    getFood(fromService: <span class="type">FoodService</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  这里做了服务类型的泛型限定, 需要这样的 Service: 是遵守 Gettable 的, 且其中的值绑定T为[Food]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFood</span>&lt;S: Gettable where S.T == [Food]&gt;<span class="params">(fromService service: S)</span></span> &#123;</span><br><span class="line">    service.<span class="keyword">get</span>() &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> result &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> food):</span><br><span class="line">            <span class="keyword">self</span>?.dataSource = food</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">self</span>?.showError(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试上, 我们穿件一个 <code>Fake_FoodService</code>, 它有两个事情： 1) 遵循 <code>Gettable</code> 协议，2) 相关类型需要是 <code>food</code> 数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FoodLaLaViewControllerTests</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fake_FoodService</span>: <span class="title">Gettable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> getWasCalled = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(completionHandler: Result&lt;[Food]&gt; -&gt; Void)</span></span> &#123;</span><br><span class="line">        getWasCalled = <span class="literal">true</span></span><br><span class="line">        completionHandler(<span class="type">Result</span>.<span class="type">Success</span>(food))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个测试我们是让他通过了, 但是你也可以返回一个失败的结果来完成 <code>ViewController</code> 的测试</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FoodLaLaViewControllerTests</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFetchFood</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeFoodService = <span class="type">Fake_FoodService</span>()</span><br><span class="line">    viewController.getFood(fromService: fakeFoodService)</span><br><span class="line"></span><br><span class="line">    <span class="type">XCTAssertTrue</span>(fakeFoodService.getWasCalled)</span><br><span class="line">    <span class="type">XCTAssertEqual</span>(viewController.dataSource.<span class="built_in">count</span>, food.<span class="built_in">count</span>)</span><br><span class="line">    <span class="type">XCTAssertEqual</span>(viewController.dataSource, food)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="POP-实践！结论"><a href="#POP-实践！结论" class="headerlink" title="POP 实践！结论"></a>POP 实践！结论</h4><blockquote>
<p>我们讨论了协议是如何在实际工作中运用的，特别是在每天编码过程中是如何把它使用到视图控制器，视图和网络中去的。本篇演讲帮助你编写出安全的，可维护的，可重用的，更统一的，模块化代码。更加易于测试的代码。相比于子类而言，协议更棒。</p>
<p>然而，协议也会被滥用。我可能使用了过多的协议了：我学习它，它是个全新的东西而且吸引眼球，我希望无时不刻都使用它……但是这是不必要的。在我的第一个例子里面，当我有一个抖动的视图和抖动函数的时候，这就很棒。只有在两个视图都需要抽象的时候，我需要重构它们的时候，放到协议里才是合理的。不要疯狂地使用协议</p>
</blockquote>
<p>以上是原文的结论, 在我的结论看来, 这片文章不仅讲了使用协议的新的, 还讲了和泛型一起使用的例子, 对原本泛型不太了解的我起到了很大的作用.</p>
<p>而且里面推荐的文章也很值得一看, 提高自己使用的水平</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/Protocol/" rel="tag"># Protocol</a>
          
            <a href="/tags/面向协议/" rel="tag"># 面向协议</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/18/bai-hu-zi-lao-tou-de-ke-cheng-xue-xi/" rel="next" title="白胡子老头的课程学习">
                <i class="fa fa-chevron-left"></i> 白胡子老头的课程学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/18/mu-qian-zai-zuo-pod-an-zhuang-de-cao-zuo/" rel="prev" title="目前在做 pod 安装的操作">
                目前在做 pod 安装的操作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">takeTrace</p>
              <p class="site-description motion-element" itemprop="description">log my study of tech/finance/other/think</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">126</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">191</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#POP"><span class="nav-number">1.</span> <span class="nav-text">POP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在不同类之间共享代码"><span class="nav-number">1.1.</span> <span class="nav-text">在不同类之间共享代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在-Protocol’s-extension-中使用-self"><span class="nav-number">1.2.</span> <span class="nav-text">在 Protocol’s extension 中使用 self</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#限制-Protocol-只能被-class-遵守"><span class="nav-number">1.3.</span> <span class="nav-text">限制 Protocol 只能被 class 遵守</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#限制只能被某个-class-遵守"><span class="nav-number">1.4.</span> <span class="nav-text">限制只能被某个 class 遵守</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其并不是一个银弹-“银弹”是指一项可使软件工程的生产力在十年内提高十倍的技术或方法-即不是在各方面各场合都是最合适的"><span class="nav-number">2.</span> <span class="nav-text">其并不是一个银弹(“银弹”是指一项可使软件工程的生产力在十年内提高十倍的技术或方法), 即不是在各方面各场合都是最合适的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对于仅限于类遵守的协议"><span class="nav-number">3.</span> <span class="nav-text">对于仅限于类遵守的协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协议组合"><span class="nav-number">4.</span> <span class="nav-text">协议组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#要求某个传入的参数遵守多个协议"><span class="nav-number">4.0.1.</span> <span class="nav-text">要求某个传入的参数遵守多个协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选协议的声明"><span class="nav-number">4.0.2.</span> <span class="nav-text">可选协议的声明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新"><span class="nav-number">4.1.</span> <span class="nav-text">更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实践-POP"><span class="nav-number">4.1.1.</span> <span class="nav-text">实践 POP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Views"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">Views</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UITable-ViewController"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">(UITable)ViewController</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POP-实践！结论"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">POP 实践！结论</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">takeTrace</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://!罗里吧嗦.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2019/02/18/Protocol-de-chu-tan-xue-xi/';
          this.page.identifier = '2019/02/18/Protocol-de-chu-tan-xue-xi/';
          this.page.title = 'Protocol 的初探学习';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://!罗里吧嗦.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  

















  





  

  

  

  
  

  

  

  

</body>
</html>
